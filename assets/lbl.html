<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.5.3.1.min.css"/>
    <link href="/assets/css/styles.css" rel="stylesheet" />
    <link href="/assets/css/extrastyles.css" rel="stylesheet" />
    <link href="/assets/css/lbl.css" rel="stylesheet" />
    <link rel="icon" type="image/png" href="/assets/img/favico-noglass.png" />
	
	<link href="/assets/css/jquery-ui.min.css" rel="stylesheet"/>
<script src="/assets/js/jquery-3.7.0.min.js"></script>
<script src="/assets/js/jquery-ui.min.js"></script>
	
<script type="text/javascript" src="/assets/js/bootstrap.bundle.5.3.1.min.js"></script>
<!-- <script src="/assets/js/lbl.js"></script>
 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Построчные Переводы</title>
<style>


:root {
  --textarea-default-height: 600px; /* Высота по умолчанию */
  --textarea-max-height: 800px; /* Максимальная высота */
}

body {
  font-family: Arial, sans-serif;
  margin: 20px;
}
  .custom-textarea {
    resize: both; /* Позволяет растягивать в любом направлении */
    overflow: auto; /* Добавляет полосы прокрутки при необходимости */
    min-height: 100px; /* Минимальная высота текстового поля */
	  height: var(--textarea-default-height); /* Высота по умолчанию */
    max-height: var(--textarea-max-height); /* Максимальная высота текстового поля */
  }

.table-container {
   flex: 1;
       resize: both; /* Позволяет растягивать в любом направлении */

    max-width: 60%; /* Задайте ширину таблицы */
  overflow-y: auto; /* Включает вертикальную прокрутку */
  	  height: var(--textarea-default-height); /* Высота по умолчанию */
  max-height: var(--textarea-max-height); /* Максимальная высота по умолчанию для десктопов */
}


  .content-container {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    gap: 20px; /* Расстояние между таблицей и textarea */
  }

  .textarea-container {
    flex: 1;
    max-width: 40%; /* Задайте ширину textarea */
  }



/* Настройки для планшетов */
@media (max-width: 1024px) {
  .table-container {
    max-height: 600px;  /* Убираем ограничение высоты для планшетов */
  }
}

/* Настройки для мобильных устройств */
@media (max-width: 600px) {
  .table-container {
    max-height: 600px; /* Убираем ограничение высоты для мобильных устройств */
  }
}


table {
  width: 100%; /* Занимает всю доступную ширину */
  border-collapse: collapse; /* Объединяет границы ячеек */
}

th, td {
  border: 1px solid black; /* Границы ячеек */
  padding: 8px; /* Внутренний отступ ячеек */
}


th:nth-child(2),
td:nth-child(2) {
  display: none;
}

label {
  font-weight: bold;
  margin-right: 10px;
}

input[type="text"],
textarea {
  width: 100%;
  margin-bottom: 10px;
}

button {
  padding: 10px 20px;
  background-color: #007bff;
  color: #fff;
  border: none;
  cursor: pointer;
}

button:hover {
  background-color: #0056b3;
}

table {
  width: 100%;
      resize: both; /* Позволяет растягивать в любом направлении */

  border-collapse: collapse;
}

table th,
table td {
  border: 1px solid #ccc;
  padding: 8px;
  text-align: left;
}

 
	.modal {
  display: none; /* Скрыто по умолчанию */
  position: fixed;
  z-index: 1;
  right: 0;
  top: 0;
  width: 100%;
  height: 100%;
  /*background-color: rgba(0, 0, 0, 0.4);  Полупрозрачный черный фон */
}

.modal-content {
  position: absolute;
  background-color: white;
  padding: 20px;
  border: 1px solid #888;
  width: 60%; /* Ширина по умолчанию для десктопов */
  max-width: 400px; /* Максимальная ширина для больших экранов */
  box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); /* Тень */
  
  /* Центрирование по горизонтали и вертикали */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

/* Настройки для планшетов */
@media (max-width: 1024px) {
  .modal-content {
    width: 70%; /* Ширина для планшетов */
  }
}

/* Настройки для мобильных устройств */
@media (max-width: 600px) {
  .modal-content {
    width: 90%; /* Ширина для мобильных устройств */
    max-width: none; /* Убираем максимальную ширину для мобильных устройств */
    padding: 10px; /* Уменьшаем отступы для мобильных устройств */
  }
}

/* Настройки для десктопов */
@media (min-width: 1025px) {
  .modal-content {
    width: 60%; /* Ширина для десктопов */
    max-width: 400px; /* Максимальная ширина для десктопов */
  }
}


.modal-header {
  cursor: move; /* Показываем, что этот элемент можно перемещать */
}

.close {
  position: absolute;
  top: 25px; /* Отступ сверху */
  right: 35px; /* Отступ справа */
  font-size: 40px;
  font-weight: bold;
  cursor: pointer;
}


.close:hover,
.close:focus {
  color: black;
  text-decoration: none;
  cursor: pointer;
}
	

  
#translationInput {
    line-height: 1.5; /* Увеличьте значение для большего межстрочного расстояния */
    /* Другие стили для textarea можно добавить здесь */
}  

  @media (max-width: 768px) {
    /* Для мобильных устройств */
    .content-container {
      flex-direction: column;
    }

    .table-container,
    .textarea-container {
      max-width: 100%;
    }
  }
	
.resizable {
  resize: horizontal; /* Позволяет изменять ширину */
  overflow: auto; /* Показывает скроллбар, если нужно */
  min-width: 10px; /* Минимальная ширина ячейки */
}

th {
  white-space: nowrap; /* Запрещает перенос текста */
  padding: 5px;
}

table {
  width: 100%; /* Таблица занимает всю доступную ширину */
}

.table-hover th {
  text-align: left; /* Выравнивание текста по левому краю */
}	
	

</style>
</head>
<body>
        <div class="mt-3">
        <div class="align-items-center align-items-center toggle-switch input-group-append">
            <div id="" class="input-group">
			
			<a href="/ru/read.php" title="Sutta and Vinaya reading" rel="noreferrer" class="me-1">
                    <svg fill="#979797" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="26px" viewBox="0 0 547.596 547.596" xml:space="preserve" stroke="#979797"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round" stroke="#CCCCCC" stroke-width="3.285576"></g><g id="SVGRepo_iconCarrier"> <g> <path d="M540.76,254.788L294.506,38.216c-11.475-10.098-30.064-10.098-41.386,0L6.943,254.788 c-11.475,10.098-8.415,18.284,6.885,18.284h75.964v221.773c0,12.087,9.945,22.108,22.108,22.108h92.947V371.067 c0-12.087,9.945-22.108,22.109-22.108h93.865c12.239,0,22.108,9.792,22.108,22.108v145.886h92.947 c12.24,0,22.108-9.945,22.108-22.108v-221.85h75.965C549.021,272.995,552.081,264.886,540.76,254.788z"></path> </g> </g></svg>
                </a>

                <a href="/ru" title="Sutta and Vinaya search" rel="noreferrer" class="me-1">
                    <img width="24px" alt="find.dhamma.gift icon" src="/assets/img/gray-white.png">
                </a>

                <div class="ms-1 form-check form-switch">
                    <input type="checkbox" class="form-check-input" id="darkSwitch">
                </div>
				  <a href="./linebyline.html" title="для Мобильных" class="ms-1 text-muted" target=""><i class="fa-solid fa-mobile-screen"></i></a>
				  
				  <a href="https://youtu.be/JkJNgMhmv64" title="Видео Инструкция" class="ms-1 text-muted" target="_blank"><i class="fa-solid fa-question"></i></a>
   
   <a href="/assets/readylinebyline.html" title="Обновить Список Готовых" class=" ms-2 me-2 text-muted" target="_blank">
<i class="fa-solid fa-list"></i>
   </a>  
   
   
   <div class="input-group-append ms-1 me-3 mb-2">
    <!-- <label>Пред / След</label> -->
    <div class=" ms-1">
        <button title="Предыдущий текст" class="input-group-append btn btn-primary" onclick="loadPrev(); loadAndCheckRanges()">
		<i class="fa-solid fa-chevron-left"></i>
<!-- 		&lt;
 -->		</button>
        <button title="Следующий текст" class="input-group-append btn btn-primary" onclick="loadNext(); loadAndCheckRanges()">
		<i class="fa-solid fa-chevron-right"></i>
<!-- 		&gt;
 -->		</button>
    </div>
 <div class="ms-1" id="checkResult" style="margin-top: 10px;"></div>

</div>
   
   <div >
      <!-- <label class="" for="indexInput" >Номер Текста:</label>	   -->
    <input  style="width: 150px;" type="search" onclick="loadAndCheckRanges()" class="form-control input-sm" id="indexInput" title="Индекс Текста пример sn56.11, an3.70, sn23.1 и т.п. " placeholder= "Номер Сутты ">
   

</div>

   <script>
        window.onload = function() {
            const urlParams = new URLSearchParams(window.location.search);
            const qParam = urlParams.get('q');
            if (qParam) {
                document.getElementById('indexInput').value = qParam;
				loadText();
				window.history.replaceState(null, '', window.location.origin + window.location.pathname);


            }
        };
    </script>

<script>
    // Функция для загрузки данных и проверки индекса
    function loadAndCheckRanges() {
        fetch('/sc/reader-rus-translations.js')
            .then(response => response.text())
            .then(data => {
                // Извлечение переменных из текста файла
                const regex = /let (\w+) = \[([\s\S]+?)\];/g;
                let match;
                let variables = {};

                while ((match = regex.exec(data)) !== null) {
                    let varName = match[1];
                    let varValues = match[2].replace(/\s+/g, '').split(',').map(val => val.replace(/['"]/g, ''));
                    variables[varName] = varValues;
                }

                // Лог извлеченных переменных
                console.log('Извлеченные переменные:', variables);

                // Обработка ввода пользователя
                const inputField = document.getElementById('indexInput');
                inputField.addEventListener('input', function () {
                    const inputValue = this.value.trim().toLowerCase();
                    console.log('Введенное значение:', inputValue);

                    let resultMessage = '❌✅Уже есть!';

                    // Проверка, какой тип текста введен (по префиксу)
                    if (inputValue.startsWith('an')) {
                        // Проверка в anranges
                        if (variables['anranges'] && variables['anranges'].includes(inputValue)) {
                            console.log('Найден в anranges:', inputValue);
                        } else {
                            console.log('Не найден в anranges:', inputValue);
                            resultMessage = '';
                        }
                    } else if (inputValue.startsWith('sn')) {
                        // Проверка в snranges
                        if (variables['snranges'] && variables['snranges'].includes(inputValue)) {
                            console.log('Найден в snranges:', inputValue);
                        } else {
                            console.log('Не найден в snranges:', inputValue);
                            resultMessage = '';
                        }
                    } else if (inputValue.startsWith('mn')) {
                        // Проверка в mnranges
                        if (variables['mnranges'] && variables['mnranges'].includes(inputValue)) {
                            console.log('Найден в mnranges:', inputValue);
                        } else {
                            console.log('Не найден в mnranges:', inputValue);
                            resultMessage = '';
                        }
                    } else if (inputValue.startsWith('dn')) {
                        // Проверка в dnranges
                        if (variables['dnranges'] && variables['dnranges'].includes(inputValue)) {
                            console.log('Найден в dnranges:', inputValue);
                        } else {
                            console.log('Не найден в dnranges:', inputValue);
                            resultMessage = '';
                        }
                    } else {
                        resultMessage = 'Неизвестный префикс';
                    }

                    // Отображение результата
                    document.getElementById('checkResult').innerHTML = resultMessage;
                });

                // Проверка значения в поле ввода при загрузке страницы
                inputField.dispatchEvent(new Event('input'));
            })
            .catch(error => {
                console.error('Ошибка при загрузке файла:', error);
            });
    }

    // Вызов функции для загрузки и проверки данных
    loadAndCheckRanges();
</script>


<div class="input-group-append ms-1">
<!--     <label for="languageSelect">Язык:</label>
 -->    <select title="Язык исходного файла" class="form-select input-sm" id="languageSelect">
      <option value="pli">Пали</option>
      <option value="en">Англ</option>
    </select>
  </div>

<div class="input-group-append ms-1 me-3">

 <button class="btn btn-primary mb-1" title="Открыть текст на find.dhamma.gift" id="linkButton2">Th.ru</button>
  <button class="btn btn-primary mb-1" title="Открыть текст на find.dhamma.gift" id="linkButton1">Fdg</button>
</div> 
 
<div class="input-group-append ms-1 me-3">
  
 <button class="btn btn-primary ms-2 me-1 input-group-append " title="Обновить перевод" onclick="loadText()">Обновить <i class="fa-solid fa-arrow-rotate-right"></i></button>
  <button class="btn btn-primary me-1" title="Сохранить JSON" onclick="downloadJson()">Сохранить <i class="fa-solid fa-download"></i></button>
  
  <button class="btn btn-primary me-1" title="Найти и Заменить" onclick="    openSearchModal();"><i class="fas fa-search"></i></button>
  
  <button id="processButton" title="Загрузить JSON" class="btn btn-secondary me-1"><i class="fa-solid fa-upload"></i></button>
  <button class="btn btn-secondary me-1"  title="Очистить окно ввода текста" onclick="clearInputs()"><i class="fa-solid fa-eraser"></i></button>
  
<div class="d-flex align-items-center">
  <div class="form-check me-2">
    <input class="form-check-input"  title="Отформатировать текст"  type="checkbox" id="lineBreakCheckbox">
    <label class="form-check-label" for="lineBreakCheckbox">
      Формат
    </label>
  </div>

  <div class="form-check">
    <input class="form-check-input" title="Добавить +edited+o в название файла"  type="checkbox" id="customTranslatorName">
    <label class="form-check-label" for="customTranslatorName">
      +edited+o
    </label>
  </div>
</div>  

  </div>
  
     <div class="input-group-append ms-1" id="checkResult" style="margin-top: 10px;"></div>

  
            </div>
			

        </div>
		
    </div>


<div id="translationJsonOutput"></div>

<div class="content-container">
  <div class="table-container mt-2 mb-3">
    <table class="table-hover">
      <thead>
        <tr>
          <th  class="resizable">Текст</th>
          <th  class="resizable">Ключ</i></th>
          <th  class="resizable">Перевод</th>
          <th  class=""><i class="fa-solid fa-link"></i></th>
        </tr>
      </thead>
      <tbody id="outputTableBody"></tbody>
    </table>
  </div>


  <div class="textarea-container my-3">
<!--      <label for="translationInput">Редактор:</label> -->	
<textarea id="translationInput" placeholder="1. Введите номер текста в 'Номер Текста'
2. Вставьте русский перевод сюда
3. Нажмите 'Обновить'

Инструмент добавит заголовок и переносы строк.

Можно будет поправить переноcы вручную.

Если перенос строки где-то не нужен, то нужно объеденить предложения в переводе."
              class="form-control custom-textarea" rows="15"></textarea>
  </div>
</div>
  
 
<script>
  function gotoLine(lineNumber) {
    const textarea = document.getElementById('translationInput');
    const lines = textarea.value.split('\n');
    
    if (lineNumber > lines.length) {
      console.log("Номер строки превышает количество строк в тексте.");
      return;
    }

    let charCount = 0;

    // Подсчитываем количество символов до нужной строки
    for (let i = 0; i < lineNumber - 1 && i < lines.length; i++) {
      charCount += lines[i].length + 1; // Учитываем символ новой строки
    }

    // Определяем конец строки
    const lineEnd = charCount + lines[lineNumber - 1].length;

    // Перемещаем фокус и выделяем строку
    textarea.focus();
    textarea.setSelectionRange(charCount, lineEnd);

    // Прокручиваем textarea, чтобы выделенная строка была видима
    textarea.scrollTop = textarea.scrollHeight * (charCount / textarea.value.length);
  }
</script>


<div class="input-group mt-2">
 
  </div>
  

<div>
 
<div id="searchModal" class="modal">
  <div class="modal-content">
    <div id="modalHeader" class="modal-header">
      <span class="close">&times;</span>
      <h3>Поиск и замена</h3>
    </div>
    <div class="modal-body">
      <!-- Ваше содержимое модального окна -->
           <label for="searchText">Найти:</label>
      <input type="text" id="searchText">
      <br>
      <label for="replaceText">Заменить на:</label>
      <input type="text" id="replaceText">
           <br><br>
      <button class="mb-1 btn btn-primary" id="findBtn">Найти</button>
      <button  class="mb-1 btn btn-primary" id="replaceOneBtn">Заменить</button>
      <button class="mb-1 btn btn-primary" id="replaceAllBtn">Заменить все</button>
      <button class="mb-1 btn btn-secondary" id="closeBtn">Закрыть</button>
<br>
  
  <button class="mb-1 btn btn-primary btn-sm" data-template="«Это – боль», «Это – скапливание боли», «Это – истечение боли», «Это – к истечению боли ведущая практика».">4би</button>
  <button class="mb-1 btn btn-primary btn-sm" data-template="«Это – боль»… «Это – к истечению боли ведущая практика». ">4би short</button>
<button class="mb-1 btn btn-primary btn-sm" data-template="Правильный взгляд, правильное намерение-заготовка, правильная речь, правильные действия, правильные быт, правильное старание, правильное памятование, правильное объединение опыта. ">б8п</button>
<button class="mb-1 btn btn-primary btn-sm" data-template="Правильный взгляд… правильное объединение опыта. ">б8п short</button>
<button class="mb-1 btn btn-primary btn-sm" data-template="Правильный взгляд… правильное объединение опыта. ">б8п short</button>
<button class="mb-1 btn btn-primary btn-sm" data-template="Так сказал Благословенный. Довольные монахи обрадовались речи Благословенного. ">Так сказал…</button>
<button class="mb-1 btn btn-primary btn-sm" data-template="—">—</button>
  
    </div>
  </div>
</div>

<div id="settings" class="modal">
  <div class="modal-content">
    <div id="modalHeader" class="modal-header">
      <span class="close">&times;</span>
      <h3>Настройки</h3>
    </div>
    <div class="modal-body">
      <!-- Ваше содержимое модального окна -->
           <label for="translator">Переводчик:</label>
      <input type="text" id="translator">
    
           <br><br>
      <button class="mb-1 btn btn-primary" id="saveSettings">Сохранить</button>
      <button  class="mb-1 btn btn-primary" id="resetSettings">Сбросить</button>
      <button class="mb-1 btn btn-primary" id="closeBtn">Отмена</button>
    </div>
  </div>
</div>
</div>


 

<button style="display: none;" class="btn btn-primary" title="Эмулировать клавишу Ctrl" id="ctrlEnterButton">Ctrl + Enter</button>
  

 

  
<div  class="my-3">
      
    
<input type="file" id="fileInput" style="display:none" accept=".json" />
<script>
  document.getElementById('processButton').addEventListener('click', function() {
    // Получаем значение из textarea
    const inputText = document.getElementById('translationInput').value;

    if (inputText.trim() === '') {
      // Если textarea пустая, открываем диалог для загрузки файла
      document.getElementById('fileInput').click();
    } else {
      // Если есть текст, продолжаем обработку JSON
      processJson(inputText);
    }
  });

  // Обработчик загрузки файла
  document.getElementById('fileInput').addEventListener('change', function(event) {
    const file = event.target.files[0];

    if (file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const fileContent = e.target.result;
        processJson(fileContent);
      };
      reader.readAsText(file);
    }
  });

  // Функция обработки JSON (из textarea или файла)
  function processJson(inputText) {
    try {
      // Преобразуем текст в объект JSON
      const jsonObject = JSON.parse(inputText);

      // Извлекаем все значения из JSON объекта
      const values = Object.values(jsonObject);

      // Объединяем значения в одну строку, разделенную переносами строки
      const result = values.join('\n');

      // Устанавливаем результат в textarea
      document.getElementById('translationInput').value = result;
    } catch (error) {
    //  alert('Ошибка при обработке JSON. Убедитесь, что введён корректный JSON.');
    
	// Выводим диалог для загрузки файла
  const proceed = confirm('Хотите загрузить файл для замены данных?');

  if (proceed) {
    // Если пользователь согласился, открываем диалог загрузки файла
    document.getElementById('fileInput').click();
  }
	}
	
  }
  
  
  
</script>


</div>


<script>
function downloadJson() {
  const language = document.getElementById('languageSelect').value;
  const indexValue = document.getElementById('indexInput').value.trim().toLowerCase();
  const translation = document.getElementById('translationInput').value.trim();

  // Разделяем текст перевода на строки
  const translationLines = translation.split('\n');

  // Объект для хранения данных JSON
  const jsonData = {};

  // Извлечение только букв из indexValue
  let lettersOnly = indexValue.match(/[a-z]+/)[0];

// Извлечение всех символов до точки
let beforeDot = indexValue.split('.')[0];
let firstNumberOnly = beforeDot.match(/[0-9]+/)[0];
//let lettersOnly = beforeDot.replace(/[0-9]/g, '');  // Удаление всех цифр, если требуется

// Проверка, содержит ли строка 'snp', 'ud' или 'dhp'
if (indexValue.includes('snp') || indexValue.includes('ud') || indexValue.includes('dhp')) {
  lettersOnly = 'kn/' + lettersOnly;
}

// Проверка, содержит ли строка 'snp' или 'ud'
if (indexValue.includes('snp') || indexValue.includes('ud')) {
  beforeDot = 'vagga' + firstNumberOnly;
} else if (indexValue.includes('dhp')) {
  beforeDot = '';
}  
  

  // Определение URL для запроса данных
  let url;
  if (language === 'pli') {
    url = `/suttacentral.net/sc-data/sc_bilara_data/root/pli/ms/sutta/${lettersOnly}/${beforeDot}/${indexValue}_root-pli-ms.json`;

  } else if (language === 'en') {
    url = `/suttacentral.net/sc-data/sc_bilara_data/translation/en/sujato/sutta/${lettersOnly}/${beforeDot}/${indexValue}_translation-en-sujato.json`;
  }

// Вывод в консоль
console.log('beforeDot:', beforeDot);
console.log('firstNumberOnly:', firstNumberOnly);
console.log('lettersOnly:', lettersOnly);
console.log('url:', url);


  // Словарь для автоматических переводов
  const translations = {
    "Paṭhamaṁ.": "Первая.",
    "Dutiyaṁ.": "Вторая.",
    "Tatiyaṁ.": "Третья.",
    "Catutthaṁ.": "Четвёртая.",
    "Pañcamaṁ.": "Пятая.",
    "Chaṭṭhaṁ.": "Шестая.",
    "Sattamaṁ.": "Седьмая.",
    "Aṭṭhamaṁ.": "Восьмая.",
    "Navamaṁ.": "Девятая.",
    "Dasamaṁ.": "Десятая.",
	"Ekādasamaṁ.": "Одниннадцатая.",
    "Dvādasamaṁ.": "Двенадцатая.",
    "Tiṁsatimaṁ.": "Тринадцатая.",
    "Cuddasamaṁ.": "Четырнадцатая.",
    "Pannarasamaṁ.": "Пятнадцатая.",
    "Soḷasamaṁ.": "Шестнадцатая.",
    "Sattarasamaṁ.": "Семнадцатая.",
    "Tassuddānaṁ": "Оглавление"
  };

  fetch(url)
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      // Преобразуем объект данных в массив пар [ключ, значение]
      const dataArray = Object.entries(data);

      // Итерация по каждому элементу данных
      dataArray.forEach(([key, value], index) => {
        let translationLine = translationLines[index] || ''; // Используем индекс итерации

        // Если значение соответствует ключу перевода, то подставляем перевод
        if (translations[value.trim()]) {
          translationLine = translations[value.trim()];
        }

        // Создаем пару ключ-значение в JSON объекте
        jsonData[key] = translationLine;
      });

      // Преобразуем JSON объект в строку
      const jsonString = JSON.stringify(jsonData, null, 2);

      // Создаем Blob с JSON строкой
      const blob = new Blob([jsonString], { type: 'application/json' });

      // Создаем ссылку для скачивания
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
	  
      let translatorName = 'sv';
      if (document.getElementById('customTranslatorName').checked) {
        translatorName = 'sv+edited+o';
      }
	  
      a.download = indexValue + '_translation-ru-' + translatorName + '.json';

      // Программно добавляем и кликаем по ссылке
      document.body.appendChild(a);
      a.click();

      // Убираем временный URL
      URL.revokeObjectURL(url);
      document.body.removeChild(a);
    })
    .catch(error => console.error('Error fetching data:', error.message));
}
</script>

<script>
function loadText() {
  const language = document.getElementById('languageSelect').value;
  const indexValue = document.getElementById('indexInput').value.trim().toLowerCase();
  let translation = document.getElementById('translationInput').value.trim();

let cleanedTranslation = translation;

  // Проверяем, является ли ввод валидным JSON
  try {
    const jsonObject = JSON.parse(translation);
    // Если это JSON, очищаем его с помощью processJson
    processJson(translation);
    return;  // Прекращаем дальнейшую обработку, так как JSON уже очищен
  } catch (error) {
    // Если это не JSON, продолжаем обычную обработку текста
  }



if (document.getElementById('lineBreakCheckbox').checked) {
  cleanedTranslation = translation.replace(/[\.…:?!] /g, match => {
    let index = translation.indexOf(match);
    if (translation.charAt(index + match.length) !== '\n') {
      return `${match}\n`;
    }
    return match;
  });
 
cleanedTranslation = cleanedTranslation.replace(/АН\s[0-9]+\.[0-9]+\s+[\s\S]*?Anguttara Nikaya.*$/gm, '');
cleanedTranslation = cleanedTranslation.replace(/СН\s[0-9]+\.[0-9]+\s+[\s\S]*?Samyutta Nikaya.*$/gm, '');

cleanedTranslation = cleanedTranslation.replace(/(\(1\)|1\)) ([а-я])/g, function(match, p1, p2) {
  return p1 + ' ' + p2.toUpperCase();
});

// Если строка начинается с цифры и не оканчивается пробелом, добавляем пробел
//cleanedTranslation = cleanedTranslation.replace(/(\([0-9]\).+?)([^\s])$/gm, function(match, p1, p2) {
//  return p1 + p2 + ' ';
//});


// добавить логику, чтобы собирал в одно предложение, короткие списки???

cleanedTranslation = cleanedTranslation.replace(/(?<![а-яА-Я])то точно также/g, 'точно также');
cleanedTranslation = cleanedTranslation.replace(/точно также/g, '\nточно также');
cleanedTranslation = cleanedTranslation.replace(/Как ты думаешь, /g, 'Как ты думаешь,\n');
cleanedTranslation = cleanedTranslation.replace(/Как вы думаете, /g, 'Как вы думаете,\n');
cleanedTranslation = cleanedTranslation.replace(/или как ты считаешь/g, '\nили как ты считаешь');
cleanedTranslation = cleanedTranslation.replace(/или как вы считаете/g, '\nили как вы считаете');
cleanedTranslation = cleanedTranslation.replace(/^.*\[Благословенный сказал\]:.*$/gm, '');
cleanedTranslation = cleanedTranslation.replace(/^.*\[Благословенный сказал:.*$/gm, '');
cleanedTranslation = cleanedTranslation.replace(/^.*\[И далее он добавил\]:.*$/gm, '');
cleanedTranslation = cleanedTranslation.replace(/\([1-9][0-9]?\) /g, '');
cleanedTranslation = cleanedTranslation.replace(/\([1-9][0-9]?-[1-9][0-9]?\) /g, '');
cleanedTranslation = cleanedTranslation.replace(/[1-9][0-9]?\) /g, '');
cleanedTranslation = cleanedTranslation.replace(/\(I\)/g, 'Первая');
cleanedTranslation = cleanedTranslation.replace(/\(II\)/g, 'Вторая');
cleanedTranslation = cleanedTranslation.replace(/\(III\)/g, 'Третья');
cleanedTranslation = cleanedTranslation.replace(/\(IV\)/g, 'Четвёртая');

cleanedTranslation = cleanedTranslation.replace(/^\*\s+/gm, '');
cleanedTranslation = cleanedTranslation.replace(/^–\s+/gm, '');
cleanedTranslation = cleanedTranslation.replace(/[0-9]*"/g, '');
  
}
  



if (document.getElementById('lineBreakCheckbox').checked) {
cleanedTranslation = cleanedTranslation.replace(/^\s*[\r\n]/gm, '');
cleanedTranslation = cleanedTranslation.replace(/([А-Яа-я»…\]])\d+\b/g, '$1');
cleanedTranslation = cleanedTranslation.replace(/([^\s])$/gm, '$1 ');

}


if (indexValue.includes("sn")) {
    if (!cleanedTranslation.startsWith("Связанные Наставления")) {
        const additionalLines = `Связанные Наставления ${indexValue.replace(/[a-z]/g, '')}\nГлава \nСутта \n\n\n`;
        cleanedTranslation = additionalLines + cleanedTranslation;
    } else if (cleanedTranslation.startsWith("Связанные Наставления")) {
        cleanedTranslation = `Связанные Наставления ${indexValue.replace(/[a-z]/g, '')}${cleanedTranslation.substring(cleanedTranslation.indexOf("\n"))}`;
    }
} else if (indexValue.includes("an")) {
    if (!cleanedTranslation.startsWith("Восходящие Наставления")) {
        const additionalLines = `Восходящие Наставления ${indexValue.replace(/[a-z]/g, '')}\nГлава \nСутта \n\n\n`;
        cleanedTranslation = additionalLines + cleanedTranslation;
    } else if (cleanedTranslation.startsWith("Восходящие Наставления")) {
        cleanedTranslation = `Восходящие Наставления ${indexValue.replace(/[a-z]/g, '')}${cleanedTranslation.substring(cleanedTranslation.indexOf("\n"))}`;
    }
} 

  document.getElementById('translationInput').value = cleanedTranslation;
  
      document.getElementById('lineBreakCheckbox').checked = false;


  const translationLines = cleanedTranslation.split('\n');
  let lettersOnly = indexValue.match(/[a-z]+/)[0];
  
// Извлечение всех символов до точки
let beforeDot = indexValue.split('.')[0];
let firstNumberOnly = beforeDot.match(/[0-9]+/)[0];
//let lettersOnly = beforeDot.replace(/[0-9]/g, '');  // Удаление всех цифр, если требуется

// Проверка, содержит ли строка 'snp', 'ud' или 'dhp'
if (indexValue.includes('snp') || indexValue.includes('ud') || indexValue.includes('dhp')) {
  lettersOnly = 'kn/' + lettersOnly;
}

// Проверка, содержит ли строка 'snp' или 'ud'
if (indexValue.includes('snp') || indexValue.includes('ud')) {
  beforeDot = 'vagga' + firstNumberOnly;
} else if (indexValue.includes('dhp')) {
  beforeDot = '';
}  
  
  
  let url;

  if (language === 'pli') {
    url = `/suttacentral.net/sc-data/sc_bilara_data/root/pli/ms/sutta/${lettersOnly}/${beforeDot}/${indexValue}_root-pli-ms.json`;
  } else if (language === 'en') {
    url = `/suttacentral.net/sc-data/sc_bilara_data/translation/en/sujato/sutta/${lettersOnly}/${beforeDot}/${indexValue}_translation-en-sujato.json`;
  }
  //    url = `/suttacentral.net/sc-data/sc_bilara_data/root/pli/ms/sutta/kn/snp/vagga3/snp3.2_root-pli-ms.json`;
//console.log(url);
  fetch(url)
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      const tableBody = document.getElementById('outputTableBody');
const translationInput = document.getElementById('translationInput'); // Ваше textarea
tableBody.innerHTML = '';

const dataArray = Object.entries(data);
const translationLines = translationInput.value.split('\n'); // Разбиваем строки translationInput
let rowCounter = 0; // Счётчик для строк

// Основной цикл по данным
dataArray.forEach(([key, value], index) => {
  const translationLine = translationLines[index] || ''; // Берём соответствующую строку из translationInput
  const texts = translationLine.split('\n'); // Разбиваем её на подстроки

  texts.forEach((text, textIndex) => {
    const currentText = texts[textIndex] || ''; // Текущая строка для вывода

    rowCounter++;
    const row = `<tr>
                  <td>${value.trimEnd()}</td>
                  <td>${key}</td>
                  <td>${currentText}</td>
                  <td><a href="#" title="${key}" onclick="gotoLine(${rowCounter})"><i class="fa-solid fa-link"></i></a></td>
                </tr>`;
    tableBody.innerHTML += row;
  });
});

// Проверяем, если translationInput содержит больше строк, чем dataArray
if (translationLines.length > dataArray.length) {
  for (let i = dataArray.length; i < translationLines.length; i++) {
    rowCounter++;
    const extraText = translationLines[i] || ''; // Дополнительные строки

    const extraRow = `<tr>
                      <td></td> <!-- Пустая ячейка для первых двух колонок -->
                      <td></td>
                      <td>${extraText}</td>
                      <td><a href="#" onclick="gotoLine(${rowCounter})"><i class="fa-solid fa-link"></i></a></td>
                    </tr>`;
    tableBody.innerHTML += extraRow;
  }
}


	  
// новый код 	  

// Добавляем обработчик клика на таблицу
document.getElementById('outputTableBody').addEventListener('click', function(event) {
    // Проверяем, был ли клик по ячейке с переводом (по столбцу с индексом 2)
    const target = event.target;
    if (target.tagName === 'TD' && target.cellIndex === 2) {
        makeCellEditable(target);
    }
});

// Функция для превращения ячейки в textarea для редактирования
function makeCellEditable(cell) {
    if (cell.querySelector('textarea')) return; // Если textarea уже есть, ничего не делаем

    const originalText = cell.textContent.trim(); // Используем textContent вместо innerText
    
    // Создаем textarea для редактирования
    const textarea = document.createElement('textarea');
    textarea.value = originalText;
    textarea.classList.add('table-textarea'); // Опционально добавляем класс для стилей

    // Устанавливаем размеры textarea в соответствии с размерами ячейки
	textarea.style.width = `${cell.clientWidth - 5}px`;
    textarea.style.height = `${cell.clientHeight - 10}px`;
    
    // Сохраняем оригинальный текст как data-атрибут
    cell.dataset.originalText = originalText;
    
    // Заменяем содержимое ячейки на textarea
    cell.textContent = '';
    cell.appendChild(textarea);
    textarea.focus();

    // Функция для завершения редактирования
    function finishEditing() {
        const newText = textarea.value.trim();
        cell.textContent = newText; // Устанавливаем новое значение (может быть пустым)
        delete cell.dataset.originalText; // Удаляем временный data-атрибут
        updateTranslationTextarea();
    }

    // Обрабатываем выход из режима редактирования
    textarea.addEventListener('blur', finishEditing);


// Обрабатываем нажатие клавиш
textarea.addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
        if (!event.ctrlKey) {
            event.preventDefault(); // Предотвращаем стандартное поведение Enter

            const cursorPosition = textarea.selectionStart; // Получаем позицию курсора
            const textBeforeCursor = textarea.value.slice(0, cursorPosition).trim(); // Текст до курсора
            const textAfterCursor = textarea.value.slice(cursorPosition).trim(); // Текст после курсора

            // Завершаем редактирование текущей ячейки
            finishEditing();

            // Получаем текущую строку и следующую строку
            const currentRow = cell.parentElement;
            let nextRow = currentRow.nextElementSibling;

            // Перемещаем текст до курсора в текущую ячейку
            cell.textContent = textBeforeCursor;

            // Начинаем сдвигать строки вниз, начиная с текущей
            let currentTextAfterCursor = textAfterCursor; // Текст, который нужно переместить вниз
            while (nextRow) {
                const nextCell = nextRow.cells[2]; // Получаем третью ячейку следующей строки
                if (nextCell) {
                    const tempText = nextCell.textContent.trim(); // Сохраняем текущий текст ячейки
                    nextCell.textContent = currentTextAfterCursor; // Перемещаем текст в следующую ячейку
                    currentTextAfterCursor = tempText; // Обновляем текст для перемещения на следующую строку
                }
                nextRow = nextRow.nextElementSibling; // Переходим к следующей строке
            }

            // Если остался текст, который нужно переместить, добавляем новую строку
            if (currentTextAfterCursor) {
                const newRow = currentRow.cloneNode(true); // Клонируем текущую строку
                newRow.cells[2].textContent = currentTextAfterCursor; // Устанавливаем текст в третью ячейку новой строки
                currentRow.parentElement.appendChild(newRow); // Добавляем новую строку в таблицу
            }

            // Переходим к редактированию следующей строки
            const nextCell = currentRow.nextElementSibling.cells[2]; // Получаем ячейку третьей колонки следующей строки
            if (nextCell) {
                makeCellEditable(nextCell); // Устанавливаем редактирование на следующую ячейку
            }
        } else {
            // Обработка Ctrl + Enter для переноса текста
            event.preventDefault(); // Предотвращаем стандартное поведение Enter

            const cursorPosition = textarea.selectionStart; // Получаем позицию курсора
            const textBeforeCursor = textarea.value.slice(0, cursorPosition).trim(); // Текст до курсора
            const textAfterCursor = textarea.value.slice(cursorPosition).trim(); // Текст после курсора

            // Завершаем редактирование текущей ячейки
            finishEditing();

            // Обновляем следующую ячейку, если она существует
            const currentRow = cell.parentElement;
            const nextRow = currentRow.nextElementSibling;
            if (nextRow) {
                const nextCell = nextRow.cells[2]; // Получаем третью ячейку следующей строки
                if (nextCell) {
                    // Устанавливаем текст до курсора в текущую ячейку
                    cell.textContent = textBeforeCursor;

                    // Перемещаем текст после курсора в следующую ячейку
                    nextCell.textContent = textAfterCursor + (nextCell.textContent.trim() ? ' ' : '') + nextCell.textContent.trim();
                    makeCellEditable(nextCell); // Начинаем редактирование следующей ячейки
                }
            }
        }
    }
	

		
// Обработка нажатия клавиши Backspace
if (event.key === 'Backspace') {
    const cursorPosition = textarea.selectionStart;
    // Если курсор в начале строки
    if (cursorPosition === 0) {
        event.preventDefault(); // Предотвращаем удаление символа
        const currentRow = cell.parentElement;
        const previousRow = currentRow.previousElementSibling;
        if (previousRow) {
            const previousCell = previousRow.cells[2]; // Получаем третью ячейку предыдущей строки
            const currentCell = currentRow.cells[2];
            const currentText = textarea.value.trim();
            
            if (currentText === '') {
                shiftCellsUp(currentRow);
            } else {
                // Если текущая ячейка не пуста, объединяем с предыдущей
                const previousText = previousCell.textContent.trim();
                previousCell.textContent = previousText + (previousText ? ' ' : '') + currentText;
                currentCell.textContent = '';
                updateSingleTranslationRow(currentCell);
                
                // После очистки текущей ячейки, сдвигаем все нижестоящие ячейки вверх
                shiftCellsUp(currentRow);
            }
            
            // Обновляем translationInput
            updateTranslationInput();
            
            // Устанавливаем фокус на предыдущую ячейку
            makeCellEditable(previousCell);
        }
    }
}



// Функция для сдвига ячеек вверх
function shiftCellsUp(startRow) {
    let rowToMove = startRow;
    while (rowToMove.nextElementSibling) {
        const nextRow = rowToMove.nextElementSibling;
        rowToMove.cells[2].textContent = nextRow.cells[2].textContent;
        rowToMove = nextRow;
    }
    // Очищаем последнюю ячейку
    rowToMove.cells[2].textContent = '';
    
    // Обновляем все затронутые строки
    let rowToUpdate = startRow;
    while (rowToUpdate) {
        updateSingleTranslationRow(rowToUpdate.cells[2]);
        rowToUpdate = rowToUpdate.nextElementSibling;
    }
}



// Функция для обновления translationInput
function updateTranslationInput() {
    const rows = document.querySelectorAll('tr');
    const translations = Array.from(rows).map(row => row.cells[2].textContent.trim());
    translationInput.value = translations.join('\n');
}
  
  
    });
}

// Функция для синхронизации изменений в таблице с полем textarea
function updateTranslationTextarea() {
    const tableRows = document.querySelectorAll('#outputTableBody tr');
    let updatedTranslation = '';
    tableRows.forEach(row => {
        const translationCell = row.cells[2]; // Ячейка с переводом (3-я ячейка в строке)
        updatedTranslation += translationCell.textContent.trim() + '\n'; // Используем textContent и удаляем лишние пробелы
    });
    document.getElementById('translationInput').value = updatedTranslation.trim(); // Обновляем textarea
}

// Инициализация: заполняем translationInput при загрузке страницы
document.addEventListener('DOMContentLoaded', updateTranslationTextarea);


// Функция для обновления translationInput только для одной строки
function updateSingleTranslationRow(cell) {
    const currentText = document.getElementById('translationInput').value;
    const rows = currentText.split('\n');

    // Определяем индекс строки, который нужно обновить
    const rowIndex = Array.prototype.indexOf.call(cell.parentElement.parentElement.children, cell.parentElement);

    // Обновляем текст только для этой строки
    rows[rowIndex] = cell.textContent.trim();

    // Обновляем содержимое translationInput
    document.getElementById('translationInput').value = rows.join('\n');
}


// новый код 	  

  
	  
    })
    .catch(error => console.error('Error fetching data:', error.message));
}
</script>


<script>



function loadPrev() {
      
	 const texttype = 'sutta';
  const indexValue = document.getElementById('indexInput').value.trim().toLowerCase();

const textPart = indexValue.split('.')[0]; // Разделяем по точке и берем первую часть
const book = indexValue.replace(/[^a-zA-Z]/g, ''); // Убираем все символы кроме букв

	const valueForApi = book + "/" + textPart + "/" + indexValue;
    const url = "/sc/api.php?fromjs=" + texttype + "/" + valueForApi + "&type=B";
    
    // Сохраняем текущее значение поля, чтобы вернуть его в случае ошибки
    const originalValue = indexValue;

    console.log("Prev URL: ", url);
    fetch(url)
        .then(response => response.text()) // Работаем с текстом, а не с JSON
        .then(data => {
            console.log("Prev Data: ", data);
            
            const newIndexValue = extractIndexValue(data);

            // Обновляем поле indexInput полученным значением
            if (newIndexValue) {
            const inputField = document.getElementById('indexInput');
			inputField.value = newIndexValue; // Замените это на логику для следующего 
			inputField.dispatchEvent(new Event('input')); // Явно вызываем событие input
	 		}

            // Вызываем loadText() для обновления данных
            loadText();
					        
        })
        .catch(error => {
            console.error('Error fetching prev data:', error);

            // В случае ошибки, возвращаем оригинальное значение поля
            document.getElementById('indexInput').value = originalValue;
        });

}

function loadNext() {
   
	 const texttype = 'sutta';
	  const indexValue = document.getElementById('indexInput').value.trim().toLowerCase();


const textPart = indexValue.split('.')[0]; // Разделяем по точке и берем первую часть
const book = indexValue.replace(/[^a-zA-Z]/g, ''); // Убираем все символы кроме букв

	const valueForApi = book + "/" + textPart + "/" + indexValue;
    const url = "/sc/api.php?fromjs=" + texttype + "/" + valueForApi + "&type=A";
    
    // Сохраняем текущее значение поля, чтобы вернуть его в случае ошибки
    const originalValue = indexValue;

    console.log("Next URL: ", url);
    fetch(url)
        .then(response => response.text()) // Работаем с текстом, а не с JSON
        .then(data => {
            console.log("Next Data: ", data);
            
            const newIndexValue = extractIndexValue(data);

            // Обновляем поле indexInput полученным значением
            if (newIndexValue) {
		    const inputField = document.getElementById('indexInput');
			inputField.value = newIndexValue; // Замените это на логику для следующего 
			inputField.dispatchEvent(new Event('input')); // Явно вызываем событие input
            }

            // Вызываем loadText() для обновления данных
            loadText();

        })
        .catch(error => {
            console.error('Error fetching next data:', error);

            // В случае ошибки, возвращаем оригинальное значение поля
            document.getElementById('indexInput').value = originalValue;
			inputField.dispatchEvent(new Event('input')); // Явно вызываем событие input
            
        });
		

}

// Функция для извлечения нового значения для поля "indexInput" из данных API
function extractIndexValue(data) {
    // Здесь нужно реализовать логику для извлечения номера текста из строки "sn17.2 Baḷisasutta"
    // Например, если это всегда строка перед первым пробелом:
    return data.split(' ')[0]; // Вернёт "sn17.2"
}

</script>



<script>


// Общий обработчик для элементов с id "indexInput" и "languageSelect"
document.addEventListener('keydown', function(event) {
    const target = event.target;
    
    // Проверяем, если фокус находится на поле indexInput или languageSelect
    if ((target.id === 'indexInput' || target.id === 'languageSelect') && event.key === 'Enter') {
        event.preventDefault(); // Отменяем стандартное поведение Enter
        loadText(); // Запускаем функцию обновления текста
    }
});




// Функция для сохранения значений
function saveInputs() {
  localStorage.setItem('indexValue', indexInput.value);
  localStorage.setItem('translationValue', translationInput.value);
 // localStorage.setItem('lineBreakCheckboxState', lineBreakCheckbox.checked);
 // Сохраняем состояние чекбокса как булево значение
}

// Функция для загрузки сохраненных значений
function loadInputs() {
  indexInput.value = localStorage.getItem('indexValue') || 'an4.170';
  translationInput.value = localStorage.getItem('translationValue') || '';
  // Если значение чекбокса в localStorage отсутствует или false, устанавливаем его в true по умолчанию
 // lineBreakCheckbox.checked = localStorage.getItem('lineBreakCheckboxState') === 'true';
}

// Вызываем функцию загрузки сохраненных значений при загрузке страницы
loadInputs();
// Сохраняем значения при изменении инпутов
indexInput.addEventListener('input', saveInputs);
translationInput.addEventListener('input', saveInputs);
//lineBreakCheckbox.addEventListener('input', saveInputs);
 
function clearInputs() {
  // Показать предупреждение
  if (confirm('Вы действительно хотите очистить перевод?')) {
    // Если пользователь подтвердил, очищаем значения инпутов
    document.getElementById('translationInput').value = '';

    // Очищаем сохраненные значения в localStorage
    localStorage.removeItem('translationValue');
    localStorage.removeItem('lineBreakCheckboxState');
  }
}

</script>
    <script src="/assets/js/dark-mode-switch/dark-mode-switch.js"></script>
  
  
      <script src="/assets/js/linksru.js"></script>



<script>
    document.getElementById('linkButton1').addEventListener('click', function() {
        var indexValue = document.getElementById('indexInput').value;
        var url = '/ru/sc?q=' + indexValue;
        window.open(url, '_blank');
    });
</script> 



<script>

    document.getElementById('linkButton2').addEventListener('click', function() {
        var indexValue = document.getElementById('indexInput').value;
        var found = false;

        for (var i = 0; i < thruLinksData.length; i++) {
            if (thruLinksData[i][0] === indexValue) {
                // Если значение найдено, взять путь из массива
                var path = thruLinksData[i][1];
                window.open('/theravada.ru/Teaching/Canon/Suttanta/Texts/' + path, '_blank');
                found = true;
                break;
            }
        }

        // Если значение не найдено, обработка для AN и SN
        if (!found) {
            // Регулярное выражение для извлечения AN или SN и числа
            var match = indexValue.match(/(an|sn)(\d+)\.\d+/i);
            if (match) {
                // Префикс (AN или SN) в верхнем регистре
                var prefix = match[1].toUpperCase();
                // Номер книги
                var bookNumber = match[2];

                // Генерация ссылки для AN и SN
                if (prefix === 'AN') {
                    var url = '/theravada.ru/Teaching/Canon/Suttanta/AN/anguttara-' + bookNumber + '.htm';
                } else if (prefix === 'SN') {
                    var url = '/theravada.ru/Teaching/Canon/Suttanta/SN/samyutta-' + bookNumber + '.htm';
                }
                window.open(url, '_blank');
            } else {
                // Если формат не соответствует AN или SN, открыть URL по умолчанию
                var url = '/ru/sc?q=' + indexValue;
                window.open(url, '_blank');
            }
        }
    });
</script>

 


<script>
$.ajax({
  url: "/assets/texts/sutta_words.txt",
  dataType: "text",
  success: function(data) {

    var accentMap = {
      "ā": "a",
      "ī": "i",
      "ū": "u",
      "ḍ": "d",
      "ḷ": "l",
      "ṃ": "ṁ",
      "ṁ": "n",
      "ṁ": "m",
      "ṅ": "n",
      "ṇ": "n",
      "ṭ": "t",
      "ñ": "n",
      "ññ": "n",
      "ss": "s",
      "aa": "a",
      "ii": "i",
      "uu": "u",
      "dd": "d",
      "kk": "k",
      "ḍḍ": "d",
      "ḷḷ": "l",
      "ṇṇ": "n",
      "ṭṭ": "t",
      "cc": "c",
      "pp": "p",
	  "cch": "c",
      "ch": "c",
      "kh": "k",
      "ph": "p",
      "th": "t",
      "ṭh": "t"
    };

    var normalize = function(term) {
      var ret = "";
      for (var i = 0; i < term.length; i++) {
          ret += accentMap[term.charAt(i)] || term.charAt(i);
      }
      return ret;
    };

    var allWords = data.split('\n');

    $("#indexInput").autocomplete({
      position: {
        my: "left bottom",
        at: "left top",
        collision: "flip"
      },
      minLength: 0,
      multiple: /[\s\*]/, // изменение регулярного выражения для разделения по пробелу или звездочке
      source: function(request, response) {
        var terms = request.term.split(/[\|\s\*]/); // изменение регулярного выражения для разделения по пробелу или звездочке или |
        var lastTerm = terms.pop().trim();
        var otherMinLength = 3;

        if (lastTerm.length < otherMinLength) {
          response([]);
          return;
        }

        var re = $.ui.autocomplete.escapeRegex(lastTerm);
        var matchbeginonly = new RegExp("^" + re, "i");
        var matchall = new RegExp(re.replace(/([a-z])\1/gi, "$1$1"), "i");

        var listBeginOnly = $.grep(allWords, function(value) {
          value = value.label || value.value || value;
          var results = matchbeginonly.test(value) || matchbeginonly.test(normalize(value));
          return results;
        });

        var listAll = $.grep(allWords, function(value) {
          value = value.label || value.value || value;
          var results = matchall.test(value) || matchall.test(normalize(value));
          return results;
        });

        listAll = listAll.filter(function(el) {
          return !listBeginOnly.includes(el);
        });

        // Ограничение количества подсказок до 10
        var maxRecord = 1000;
        var resultList = listBeginOnly.concat(listAll).slice(0, maxRecord);

        response(resultList);
      },
      focus: function(event, ui) {
        // Удаляем автоматическое введение при наведении мыши
        return false;
      },
      select: function(event, ui) {
  var terms = this.value.split(/([\|\s\*])/);
  terms.pop();
  terms.push(ui.item.value);
  
  for (var i = 1; i < terms.length; i += 2) {
    if (terms[i] === "*") {
      terms[i] = "*";
    } else if (terms[i] === "|") {
      terms[i] = "|";
    } else {
      terms[i] = " ";
    }
  }

  this.value = terms.join("");
  return false;
}

    }).autocomplete("widget").addClass("fixed-height");
  }
});
</script>

  <script>
    const translationInput = document.getElementById('translationInput');
    const searchModal = document.getElementById('searchModal');
    const searchText = document.getElementById('searchText');
    const replaceText = document.getElementById('replaceText');
    const findBtn = document.getElementById('findBtn');
    const replaceOneBtn = document.getElementById('replaceOneBtn');
    const replaceAllBtn = document.getElementById('replaceAllBtn');
    const closeBtn = document.getElementById('closeBtn');

    let lastIndex = 0;

    // Открытие модального окна с логированием
    function openSearchModal() {
      console.log('Opening search modal');
      lastIndex = 0; // Сбрасываем индекс при каждом открытии
      searchModal.style.display = 'block';
      searchText.focus();
    }

    // Закрытие модального окна с логированием
    function closeSearchModal() {
      console.log('Closing search modal');
      searchModal.style.display = 'none';
      setTimeout(() => {
        translationInput.focus(); // Возвращаем фокус на textarea
      }, 0);
    }

    // Поиск текста
    findBtn.addEventListener('click', function () {
      const searchValue = searchText.value;
      if (searchValue) {
        const content = translationInput.value;
        lastIndex = content.indexOf(searchValue, lastIndex + 1);

        if (lastIndex !== -1) {
          console.log(`Text found at index ${lastIndex}`);
          translationInput.focus();
          translationInput.setSelectionRange(lastIndex, lastIndex + searchValue.length);
        } else {
          alert('Совпадений больше нет');
          console.log('No more matches found');
          lastIndex = 0; // Сброс для нового поиска
        }
      }
    });

    // Замена одного совпадения
    replaceOneBtn.addEventListener('click', function () {
      const searchValue = searchText.value;
      const replaceValue = replaceText.value;
      if (searchValue) {
        const content = translationInput.value;
        lastIndex = content.indexOf(searchValue, lastIndex);

        if (lastIndex !== -1) {
          translationInput.value = 
            content.slice(0, lastIndex) + replaceValue + content.slice(lastIndex + searchValue.length);
          console.log(`Replaced text at index ${lastIndex}`);
          lastIndex += replaceValue.length;
          translationInput.focus();
          translationInput.setSelectionRange(lastIndex, lastIndex);
        } else {
          alert('Совпадений больше нет');
          console.log('No more matches found for replacement');
          lastIndex = 0;
        }
      }
    });

    // Замена всех совпадений
    replaceAllBtn.addEventListener('click', function () {
      const searchValue = searchText.value;
      const replaceValue = replaceText.value;
      if (searchValue) {
        const regex = new RegExp(searchValue, 'g');
        translationInput.value = translationInput.value.replace(regex, replaceValue);
        console.log('Replaced all occurrences');
      }
    });

    // Закрытие окна при нажатии "Закрыть"
    closeBtn.addEventListener('click', function() {
      console.log('Close button clicked');
      closeSearchModal();
    });

    // Глобальный обработчик нажатия клавиш Ctrl + Shift + F или Ctrl + Shift + H
   document.addEventListener('keydown', function (e) {
  if (e.ctrlKey && e.shiftKey && (e.code === 'KeyF' || e.code === 'KeyH')) {
    console.log('Key combination pressed: ', e.code);
    e.preventDefault();
    openSearchModal();
  }
});

    // Закрытие окна при клике вне его
    window.addEventListener('click', function (e) {
      if (e.target == searchModal) {
        console.log('Clicked outside the modal');
        closeSearchModal();
      }
    });


// Логика для перемещения модального окна
const modal = document.getElementById("searchModal");
const modalHeader = document.getElementById("modalHeader");
let isDragging = false;
let offsetX = 0, offsetY = 0;

modalHeader.addEventListener('mousedown', function (e) {
  isDragging = true;
  offsetX = e.clientX - modal.offsetLeft;
  offsetY = e.clientY - modal.offsetTop;
  document.body.style.cursor = "move"; // Меняем курсор на перетаскивание
});

document.addEventListener('mousemove', function (e) {
  if (isDragging) {
    modal.style.left = (e.clientX - offsetX) + "px";
    modal.style.top = (e.clientY - offsetY) + "px";
  }
});

document.addEventListener('mouseup', function () {
  isDragging = false;
  document.body.style.cursor = "default"; // Возвращаем курсор обратно
});

// Открытие и закрытие модального окна по нажатию клавиш
document.addEventListener('keydown', function (e) {
  if (e.ctrlKey && e.shiftKey && (e.code === 'KeyF' || e.code === 'KeyH')) {
    console.log('Key combination pressed: ', e.code);
    e.preventDefault();
    openSearchModal();
  }
});

function openSearchModal() {
  console.log("Opening search modal");
  modal.style.display = "block";
}

const closeButton = document.querySelector('.close');
closeButton.addEventListener('click', function() {
  console.log("Close button clicked");
  modal.style.display = "none";
});

// Закрытие модального окна при клике вне его
window.addEventListener('click', function(event) {
  if (event.target == modal) {
    modal.style.display = "none";
  }
});



  </script>
  


<script>
document.querySelectorAll('button[data-template]').forEach(function(button) {
    button.addEventListener('click', function() {
        var translationInput = document.getElementById('translationInput');

        // Проверяем, найден ли элемент и не является ли он null
        if (!translationInput) {
            console.error("Element with id 'translationInput' not found");
            return;
        }

        var textToInsert = button.getAttribute('data-template');

        // Проверяем, чтобы текст для вставки не был null или undefined
        if (textToInsert === null || textToInsert === undefined) {
            console.error("No text found in data-template attribute");
            return;
        }

        // Для поддержания позиции курсора
        var startPos = translationInput.selectionStart;
        var endPos = translationInput.selectionEnd;

        // Вставляем текст на позицию курсора
        var beforeCursor = translationInput.value.substring(0, startPos);
        var afterCursor = translationInput.value.substring(endPos, translationInput.value.length);
        translationInput.value = beforeCursor + textToInsert + afterCursor;

        // Устанавливаем курсор после вставленного текста
        translationInput.selectionStart = translationInput.selectionEnd = startPos + textToInsert.length;

        // Опционально фокусируем input
        translationInput.focus();
    });
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
        loadText();
		loadAndCheckRanges();
    });
</script>

<script src="/assets/js/fontawesome.6.6.all.js" defer></script>
 <script src="/assets/js/smoothScroll.js" defer></script>


<script>

// Функция для добавления обработчиков событий
function init() {
  const textarea = document.getElementById('translationInput');
  if (!textarea) {
    console.error('Textarea not found!');
    return;  // Если textarea не найден, прерываем выполнение
  }

  let typingTimer; // Таймер для отслеживания времени после нажатия клавиш
  const typingInterval = 700; // Время задержки перед вызовом функции (500 мс)

  function handleKeyPress(event) {
    const key = event.key || event.keyCode;

    // Проверяем нажатие клавиш Enter, Backspace, Delete или пробела
    if (key === 'Enter' || key === 'Backspace' || key === 'Delete' || event.keyCode === 13 || event.keyCode === 8 || event.keyCode === 46 || event.keyCode === 32 || event.keyCode === 229) {
      clearTimeout(typingTimer); // Сбрасываем таймер при нажатии клавиши
      typingTimer = setTimeout(loadText, typingInterval); // Запускаем таймер для вызова функции
    }
  }

  // Добавляем обработчики событий
  textarea.addEventListener('keyup', handleKeyPress);

  textarea.addEventListener('input', function() {
    clearTimeout(typingTimer); // Сбрасываем таймер при любом изменении текста
    typingTimer = setTimeout(loadText, typingInterval); // Запускаем таймер для вызова функции после изменения
  });
}

// Убедимся, что код выполняется после загрузки DOM
document.addEventListener('DOMContentLoaded', init);

</script>

	
</body>
</html>